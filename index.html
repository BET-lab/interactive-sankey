<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sankey Diagram</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #333333;
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 10px;
        }

        .header p {
            color: rgba(0, 0, 0, 0.6);
            font-size: 1rem;
        }

        .main-layout {
            flex: 1;
            display: flex;
            height: calc(100vh - 120px);
        }

        .data-editor-panel {
            width: 350px;
            background: rgba(0, 0, 0, 0.03);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow-y: auto;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .panel-header {
            margin-bottom: 20px;
        }

        .panel-header h3 {
            color: #333333;
            margin-bottom: 15px;
            font-weight: 400;
        }

        .file-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #4a90e2;
            color: white;
        }

        .btn-primary:hover {
            background: #357abd;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.8rem;
            background: #e74c3c;
            color: white;
        }

        .btn-small:hover {
            background: #c0392b;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
            padding: 4px 8px;
            font-size: 0.7rem;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .editor-section {
            margin-bottom: 30px;
        }

        .editor-section h4 {
            color: #333333;
            margin-bottom: 10px;
            font-weight: 500;
            font-size: 1.1rem;
        }

        .data-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.8);
        }

        .data-item {
            padding: 12px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            background: white;
            margin-bottom: 2px;
        }

        .data-item:last-child {
            border-bottom: none;
        }

        .data-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .data-item-title {
            font-weight: 500;
            color: #333333;
        }

        .data-item-fields {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.8rem;
        }

        .data-item-fields .field-group:nth-child(3),
        .data-item-fields .field-group:nth-child(4) {
            grid-column: span 1;
        }

        /* For links with more fields, allow them to span full width when needed */
        .data-item-fields .field-group:nth-child(5),
        .data-item-fields .field-group:nth-child(6) {
            grid-column: span 1;
        }

        .field-group {
            display: flex;
            flex-direction: column;
        }

        .field-group label {
            color: rgba(0, 0, 0, 0.7);
            font-size: 0.7rem;
            margin-bottom: 2px;
        }

        .field-group input, .field-group select, .field-group textarea {
            padding: 4px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            font-size: 0.8rem;
        }

        .field-group textarea {
            resize: vertical;
            min-height: 40px;
            font-family: inherit;
            line-height: 1.4;
        }

        .appearance-fields {
            grid-column: span 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .coordinate-fields {
            grid-column: span 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        /* Icon field styling */
        .icon-field-group {
            grid-column: span 2;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            background: #f9f9f9;
        }

        .icon-input-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .icon-options {
            display: flex;
            gap: 15px;
            margin-bottom: 8px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .radio-option input[type="radio"] {
            margin: 0;
        }

        .icon-input-area {
            min-height: 40px;
            padding: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .no-input {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 10px;
        }

        .text-input-area input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            text-align: center;
        }

        .text-input-area small {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 12px;
        }

        .svg-input-area textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        .svg-input-buttons {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }

        .svg-input-buttons button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .icon-preview {
            padding: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-preview .no-icon {
            color: #666;
            font-style: italic;
        }

        .icon-preview svg {
            max-width: 24px;
            max-height: 24px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .controls h3 {
            color: #333333;
            margin-bottom: 15px;
            font-weight: 400;
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-item label {
            color: rgba(0, 0, 0, 0.8);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .control-item input[type="range"],
        .control-item input[type="color"],
        .control-item select {
            padding: 8px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.05);
            color: #333333;
        }

        .control-item input[type="range"] {
            width: 120px;
        }

        .control-item select {
            min-width: 100px;
        }

        .control-item select option {
            background: #ffffff;
            color: #333333;
        }

        .control-item input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .control-item label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .visualization-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.02);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
        }

        #sankey-diagram {
            width: 100%;
            height: 100%;
            min-height: 500px;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node.draggable {
            cursor: grab;
        }

        .node:hover .node-circle {
            stroke-width: 4;
            filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
        }

        .node.dragging {
            cursor: grabbing !important;
            transition: none !important; /* Disable transitions during drag */
        }

        .node.dragging .node-circle {
            stroke-width: 5;
            filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.5));
            transition: none !important; /* Disable transitions during drag */
        }

        .node.dragging .node-icon {
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.6));
            transition: none !important;
        }

        .node:hover .node-icon {
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .node-interaction-area {
            /* Uncomment the line below to visualize interaction areas during development */
            /* fill: rgba(255, 0, 0, 0.1) !important; */
        }

        /* Remove hover transform to prevent jittering */

        .node-circle {
            fill: #4a90e2;
            stroke: #2c5aa0;
            stroke-width: 3;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .node-icon {
            pointer-events: none;
        }

        .node-icon-text {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .node-icon-svg {
            pointer-events: none;
            overflow: visible;
        }

        .node-icon-svg svg {
            pointer-events: none;
            display: block !important;
            width: 100% !important;
            height: 100% !important;
            max-width: none !important;
            max-height: none !important;
        }

        .node-label {
            font-size: 12px;
            font-weight: 500;
            fill: #333333;
            text-anchor: middle;
            pointer-events: none;
        }

        .link {
            opacity: 1.0;  /* Fixed to 1.0 (no transparency) */
            transition: opacity 0.3s ease;
        }

        .link.no-transition {
            transition: none !important;
        }

        .link.drawing {
            clip-path: inset(0 100% 0 0);
            animation: revealLinkFromLeft 0.8s ease-out forwards;
        }

        @keyframes revealLinkFromLeft {
            0% {
                clip-path: inset(0 100% 0 0);
                opacity: 0;
            }
            10% {
                opacity: 1.0;  /* Fixed to 1.0 (no transparency) */
            }
            100% {
                clip-path: inset(0 0 0 0);
                opacity: 1.0;  /* Fixed to 1.0 (no transparency) */
            }
        }

        /* Link hover handled via JavaScript to prevent conflicts */

        .link-hidden {
            opacity: 0;
            pointer-events: none;
        }

        .node-hidden {
            opacity: 0.1;
            pointer-events: none;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .tooltip strong {
            color: #4a90e2;
            display: block;
            margin-bottom: 4px;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #333333;
            font-size: 1.2rem;
        }

        .error {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #ff6b6b;
            font-size: 1.2rem;
            text-align: center;
        }



        .link {
            cursor: pointer;
        }

        .links path {
            /* mix-blend-mode: multiply; */  /* Disabled - causes overlapping links to appear darker */
            mix-blend-mode: normal;  /* Use normal blending to prevent transparency effects */
        }

        @media (max-width: 768px) {
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-item {
                width: 100%;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Interactive Sankey Diagram</h1>
        <p>Click on nodes to explore the flow relationships</p>
    </div>

    <div class="main-layout">
        <!-- Data Editor Panel -->
        <div class="data-editor-panel">
            <div class="panel-header">
                <h3>Data Editor</h3>
                <div class="file-controls">
                    <button id="loadFile" class="btn btn-primary">Load JSON</button>
                    <button id="saveFile" class="btn btn-success">Save JSON</button>
                    <input type="file" id="fileInput" accept=".json" style="display: none;">
                </div>
            </div>

            <!-- Nodes Editor -->
            <div class="editor-section">
                <h4>Nodes</h4>
                <button id="addNode" class="btn btn-small">+ Add Node</button>
                <div id="nodesList" class="data-list"></div>
            </div>

            <!-- Links Editor -->
            <div class="editor-section">
                <h4>Links</h4>
                <button id="addLink" class="btn btn-small">+ Add Link</button>
                <div id="linksList" class="data-list"></div>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <div class="controls">
                <h3>Visualization Controls</h3>
                <div class="control-group">
                    <div class="control-item">
                        <label for="nodeColor">Node Color</label>
                        <input type="color" id="nodeColor" value="#4a90e2">
                    </div>
                    <!-- Link Opacity feature disabled (always 1.0) -->
                    <div class="control-item" style="display: none;">
                        <label for="linkOpacity">Link Opacity</label>
                        <input type="range" id="linkOpacity" min="0.1" max="1" step="0.1" value="1.0">
                    </div>
                    <div class="control-item">
                        <label for="animationSpeed">Animation Speed</label>
                        <select id="animationSpeed">
                            <option value="0.2">Fast</option>
                            <option value="0.5" selected>Normal</option>
                            <option value="1">Slow</option>
                        </select>
                    </div>
                    <div class="control-item">
                        <label>
                            <input type="checkbox" id="coordinateMode" checked>
                            Use Absolute Coordinates
                        </label>
                        <small style="color: rgba(0,0,0,0.6); font-size: 0.8rem; margin-top: 2px;">
                            Enable node dragging
                        </small>
                    </div>
                    <div class="control-item">
                        <button id="showAllBtn" class="btn btn-primary">Show All Nodes & Links</button>
                        <small style="color: rgba(0,0,0,0.6); font-size: 0.8rem; margin-top: 2px;">
                            Make all elements visible and draggable
                        </small>
                    </div>
                </div>
            </div>

            <div class="visualization-container">
                <div id="sankey-diagram">
                    <div class="loading">Loading Sankey diagram...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- D3.js and d3-sankey libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

    <script>
        // Configuration
        const config = {
            linkOpacity: 1.0,  // Fixed to 1.0 (no transparency)
            nodeColor: '#4a90e2',
            animationDuration: 500,
            useAbsoluteCoordinates: true  // New: Enable absolute coordinate mode
        };

        // Animation state
        let isAnimating = false;
        const animationDuration = config.animationDuration;

        // Drag state
        let isDragging = false;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let animationFrameId = null;

        // Progressive disclosure state
        const visibleNodes = new Set();
        const visibleLinks = new Set();
        const previouslyVisibleLinks = new Set(); // Track previously visible links

        // Global references for updates
        let sankeyData = null;
        let svg = null;
        let nodes = null;
        let links = null;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing Sankey diagram...');
            initializeControls();
            loadData();
        });

        // Initialize control event listeners
        function initializeControls() {
            // Skip nodeWidth and nodePadding as they're removed from UI
            
            document.getElementById('nodeColor').addEventListener('input', function(e) {
                config.nodeColor = e.target.value;
                updateNodeColors();
            });

            // Link opacity disabled - always use 1.0
            document.getElementById('linkOpacity').addEventListener('input', function(e) {
                // config.linkOpacity = parseFloat(e.target.value);
                config.linkOpacity = 1.0;  // Always use 1.0 (no transparency)
                updateLinkOpacity();
            });

            document.getElementById('animationSpeed').addEventListener('change', function(e) {
                config.animationSpeed = parseFloat(e.target.value);
                animationDuration = config.animationSpeed * 1000;
            });

            document.getElementById('coordinateMode').addEventListener('change', function(e) {
                config.useAbsoluteCoordinates = e.target.checked;
                updateDiagram();
                // Update draggable state immediately for better UX
                setTimeout(() => {
                    updateDraggableNodes();
                }, 100);
            });

            // Data editor controls
            document.getElementById('addNode').addEventListener('click', addNewNode);
            document.getElementById('addLink').addEventListener('click', addNewLink);
            document.getElementById('loadFile').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            document.getElementById('saveFile').addEventListener('click', saveDataToFile);
            document.getElementById('fileInput').addEventListener('change', loadDataFromFile);
            document.getElementById('showAllBtn').addEventListener('click', showAllNodesAndLinks);
        }

        // Data Editor Functions
        function updateDataEditor() {
            updateNodesList();
            updateLinksList();
        }

        function updateNodesList() {
            const nodesList = document.getElementById('nodesList');
            nodesList.innerHTML = '';

            sankeyData.nodes.forEach((node, index) => {
                const nodeItem = createNodeItem(node, index);
                nodesList.appendChild(nodeItem);
            });
        }

        function createNodeItem(node, index) {
            const div = document.createElement('div');
            div.className = 'data-item';
            
            // Get current icon value (support both old and new structure)
            const currentIcon = node.style?.icon || node.icon || '';
            
            div.innerHTML = `
                <div class="data-item-header">
                    <span class="data-item-title">${node.name}</span>
                    <button class="btn btn-danger" onclick="deleteNode(${index})">Delete</button>
                </div>
                <div class="data-item-fields">
                    <div class="field-group">
                        <label>Name</label>
                        <textarea rows="2" placeholder="Node name (use Enter for new lines)" onchange="updateNodeProperty(${index}, 'name', this.value)">${node.name}</textarea>
                        <small style="color: #666; font-size: 11px; margin-top: 2px; display: block;">줄바꿈(Enter)을 사용하여 여러 줄 텍스트를 만들 수 있습니다</small>
                    </div>
                    <div class="field-group">
                        <label>Level</label>
                        <input type="number" value="${node.level || 0}" onchange="updateNodeProperty(${index}, 'level', parseInt(this.value))">
                    </div>
                    <div class="field-group">
                        <label>Color</label>
                        <input type="color" value="${node.color || '#4a90e2'}" onchange="updateNodeProperty(${index}, 'color', this.value)">
                    </div>
                    <div class="field-group">
                        <label>Description</label>
                        <input type="text" value="${node.description || ''}" onchange="updateNodeProperty(${index}, 'description', this.value)">
                    </div>
                    <div class="field-group icon-field-group">
                        <label>Icon</label>
                        <div class="icon-input-container">
                            <div class="icon-options">
                                <label class="radio-option">
                                    <input type="radio" name="icon-type-${index}" value="none" ${!currentIcon ? 'checked' : ''} onchange="updateIconType(${index}, 'none')">
                                    <span>No Icon</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="icon-type-${index}" value="text" ${currentIcon && !currentIcon.includes('<svg') ? 'checked' : ''} onchange="updateIconType(${index}, 'text')">
                                    <span>Text</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="icon-type-${index}" value="svg" ${currentIcon && currentIcon.includes('<svg') ? 'checked' : ''} onchange="updateIconType(${index}, 'svg')">
                                    <span>SVG</span>
                                </label>
                            </div>
                            <div class="icon-input-area" id="icon-input-${index}">
                                ${createIconInputArea(index, currentIcon)}
                            </div>
                            <div class="icon-preview" id="icon-preview-${index}">
                                ${currentIcon || '<span class="no-icon">No icon</span>'}
                            </div>
                        </div>
                    </div>
                    <div class="appearance-fields">
                        <div class="field-group">
                            <label>
                                <input type="checkbox" ${node.hideCircle ? 'checked' : ''} onchange="updateNodeProperty(${index}, 'hideCircle', this.checked)">
                                Hide Node Circle
                            </label>
                        </div>
                        <div class="field-group">
                            <label>Icon Size</label>
                            <input type="number" min="12" max="100" value="${node.iconSize || 24}" onchange="updateNodeProperty(${index}, 'iconSize', parseInt(this.value))" step="2">
                        </div>
                    </div>
                    <div class="coordinate-fields">
                        <div class="field-group">
                            <label>X Coordinate</label>
                            <input type="number" value="${node.x || ''}" onchange="updateNodeProperty(${index}, 'x', this.value === '' ? undefined : parseFloat(this.value))" id="node-x-${index}">
                        </div>
                        <div class="field-group">
                            <label>Y Coordinate</label>
                            <input type="number" value="${node.y || ''}" onchange="updateNodeProperty(${index}, 'y', this.value === '' ? undefined : parseFloat(this.value))" id="node-y-${index}">
                        </div>
                    </div>
                </div>
            `;
            return div;
        }

        function updateLinksList() {
            const linksList = document.getElementById('linksList');
            linksList.innerHTML = '';

            sankeyData.links.forEach((link, index) => {
                const linkItem = createLinkItem(link, index);
                linksList.appendChild(linkItem);
            });
        }

        function createLinkItem(link, index) {
            const div = document.createElement('div');
            div.className = 'data-item';
            
            // Create options for source and target dropdowns
            const nodeOptions = sankeyData.nodes.map(node => 
                `<option value="${node.id}" ${node.id === link.source ? 'selected' : ''}>${node.name}</option>`
            ).join('');

            const targetOptions = sankeyData.nodes.map(node => 
                `<option value="${node.id}" ${node.id === link.target ? 'selected' : ''}>${node.name}</option>`
            ).join('');

            // Get readable names for source and target
            const sourceName = sankeyData.nodes.find(n => n.id === link.source)?.name || link.source;
            const targetName = sankeyData.nodes.find(n => n.id === link.target)?.name || link.target;
            
            div.innerHTML = `
                <div class="data-item-header">
                    <span class="data-item-title">${sourceName} → ${targetName}</span>
                    <button class="btn btn-danger" onclick="deleteLink(${index})">Delete</button>
                </div>
                <div class="data-item-fields">
                    <div class="field-group">
                        <label>Source</label>
                        <select onchange="updateLinkProperty(${index}, 'source', this.value)">
                            ${nodeOptions}
                        </select>
                    </div>
                    <div class="field-group">
                        <label>Target</label>
                        <select onchange="updateLinkProperty(${index}, 'target', this.value)">
                            ${targetOptions}
                        </select>
                    </div>
                    <div class="field-group">
                        <label>Value</label>
                        <input type="number" value="${link.value}" onchange="updateLinkProperty(${index}, 'value', parseFloat(this.value))">
                    </div>
                    <div class="field-group">
                        <label>Color</label>
                        <input type="color" value="${link.color || '#4a90e2'}" onchange="updateLinkProperty(${index}, 'color', this.value)">
                        <small style="color: #666; font-size: 11px; margin-top: 2px; display: block;">기본색 (그래디언트가 없을 때 사용)</small>
                    </div>
                    <div class="field-group">
                        <label>Gradient Start</label>
                        <input type="color" value="${link.style?.gradient?.start || link.gradient?.start || link.color || '#4a90e2'}" onchange="updateLinkGradient(${index}, 'start', this.value)">
                        <small style="color: #666; font-size: 11px; margin-top: 2px; display: block;">그래디언트 시작색 (소스 노드 쪽)</small>
                    </div>
                    <div class="field-group">
                        <label>Gradient End</label>
                        <input type="color" value="${link.style?.gradient?.end || link.gradient?.end || d3.color(link.color || '#4a90e2').darker(0.3)}" onchange="updateLinkGradient(${index}, 'end', this.value)">
                        <small style="color: #666; font-size: 11px; margin-top: 2px; display: block;">그래디언트 끝색 (타겟 노드 쪽)</small>
                    </div>
                </div>
            `;
            return div;
        }

        function addNewNode() {
            const nodeNumber = sankeyData.nodes.length + 1;
            const newNode = {
                id: `node_${nodeNumber}`,
                name: `Node ${nodeNumber}`,
                level: 0,
                color: '#4a90e2',
                description: 'New node description',
                visible: true
            };
            
            sankeyData.nodes.push(newNode);
            
            // Automatically add to visible nodes if we're showing all
            visibleNodes.add(newNode.id);
            
            updateDataEditor();
            updateDiagram();
        }

        function addNewLink() {
            if (sankeyData.nodes.length < 2) {
                alert('You need at least 2 nodes to create a link');
                return;
            }

            const linkNumber = sankeyData.links.length + 1;
            const newLink = {
                id: `link_${linkNumber}`,
                source: sankeyData.nodes[0].id,
                target: sankeyData.nodes[1].id,
                value: 1,
                color: '#4a90e2',
                visible: true,
                description: 'New link description',
                style: {
                    gradient: {
                        start: '#4a90e2',
                        end: '#357abd'
                    }
                }
            };
            
            sankeyData.links.push(newLink);
            
            // Automatically add to visible links
            visibleLinks.add(newLink.id);
            
            // Also make sure both connected nodes are visible
            visibleNodes.add(newLink.source);
            visibleNodes.add(newLink.target);
            
            console.log('Added new link:', newLink);
            console.log('Visible links now:', Array.from(visibleLinks));
            
            updateDataEditor();
            updateDiagram();
        }

        // Create icon input area based on current icon type
        function createIconInputArea(index, currentIcon) {
            if (!currentIcon) {
                return '<div class="no-input">Select an icon type above</div>';
            } else if (currentIcon.includes('<svg')) {
                return `
                    <div class="svg-input-area">
                        <textarea placeholder="Paste SVG code here or click 'Import SVG' button" 
                                  onchange="updateNodeIcon(${index}, this.value)"
                                  rows="4">${currentIcon.replace(/"/g, '&quot;')}</textarea>
                        <div class="svg-input-buttons">
                            <button type="button" onclick="importSvgFile(${index})" class="btn btn-secondary">Import SVG File</button>
                            <button type="button" onclick="clearIcon(${index})" class="btn btn-secondary">Clear</button>
                        </div>
                        <input type="file" id="svg-file-${index}" accept=".svg" style="display: none" onchange="handleSvgFileImport(${index}, this)">
                    </div>
                `;
            } else {
                return `
                    <div class="text-input-area">
                        <input type="text" placeholder="Enter text (emoji, symbol, or short text)" 
                               value="${currentIcon.replace(/"/g, '&quot;')}"
                               onchange="updateNodeIcon(${index}, this.value)"
                               maxlength="10">
                        <small>Examples: ⚡, 🌟, A, 1, etc.</small>
                    </div>
                `;
            }
        }

        // Update icon type when radio button changes
        function updateIconType(index, type) {
            const inputArea = document.getElementById(`icon-input-${index}`);
            const previewArea = document.getElementById(`icon-preview-${index}`);
            
            let newIcon = '';
            switch (type) {
                case 'none':
                    newIcon = '';
                    inputArea.innerHTML = '<div class="no-input">No icon selected</div>';
                    previewArea.innerHTML = '<span class="no-icon">No icon</span>';
                    break;
                case 'text':
                    newIcon = '⚡'; // Default text icon
                    inputArea.innerHTML = `
                        <div class="text-input-area">
                            <input type="text" placeholder="Enter text (emoji, symbol, or short text)" 
                                   value="⚡"
                                   onchange="updateNodeIcon(${index}, this.value)"
                                   maxlength="10">
                            <small>Examples: ⚡, 🌟, A, 1, etc.</small>
                        </div>
                    `;
                    previewArea.innerHTML = '⚡';
                    break;
                case 'svg':
                    newIcon = '<svg viewBox="0 0 24 24" width="20" height="20"><circle cx="12" cy="12" r="8" fill="white"/></svg>';
                    inputArea.innerHTML = `
                        <div class="svg-input-area">
                            <textarea placeholder="Paste SVG code here or click 'Import SVG' button" 
                                      onchange="updateNodeIcon(${index}, this.value)"
                                      rows="4">${newIcon.replace(/"/g, '&quot;')}</textarea>
                            <div class="svg-input-buttons">
                                <button type="button" onclick="importSvgFile(${index})" class="btn btn-secondary">Import SVG File</button>
                                <button type="button" onclick="clearIcon(${index})" class="btn btn-secondary">Clear</button>
                            </div>
                            <input type="file" id="svg-file-${index}" accept=".svg" style="display: none" onchange="handleSvgFileImport(${index}, this)">
                        </div>
                    `;
                    previewArea.innerHTML = newIcon;
                    break;
            }
            
            // Update the node icon
            updateNodeIcon(index, newIcon);
        }

        // Update node icon and refresh preview
        function updateNodeIcon(index, iconValue) {
            // Support both old structure (node.icon) and new structure (node.style.icon)
            if (!sankeyData.nodes[index].style) {
                sankeyData.nodes[index].style = {};
            }
            sankeyData.nodes[index].style.icon = iconValue;
            sankeyData.nodes[index].icon = iconValue; // Keep backward compatibility
            
            // Update preview
            const previewArea = document.getElementById(`icon-preview-${index}`);
            if (previewArea) {
                const iconSize = sankeyData.nodes[index].iconSize || 24;
                const previewSize = Math.min(iconSize, 32); // Limit preview size
                
                if (iconValue) {
                    if (iconValue.includes('<svg')) {
                        // Process SVG for preview
                        const processedSvg = processSvgForIcon(iconValue, previewSize);
                        previewArea.innerHTML = processedSvg;
                    } else {
                        // Text icon
                        const fontSize = Math.max(12, previewSize * 0.75);
                        previewArea.innerHTML = `<span style="font-size: ${fontSize}px; font-weight: bold;">${iconValue}</span>`;
                    }
                } else {
                    previewArea.innerHTML = '<span class="no-icon">No icon</span>';
                }
            }
            
            // Update diagram
            updateDiagram();
        }

        // Process SVG for use as node icon
        function processSvgForIcon(svgContent, iconSize = 24) {
            try {
                // Clean the SVG content first
                let cleanedSvg = svgContent.trim();
                cleanedSvg = cleanedSvg.replace(/<\?xml[^>]*\?>/g, '');
                cleanedSvg = cleanedSvg.replace(/<!DOCTYPE[^>]*>/g, '');
                cleanedSvg = cleanedSvg.trim();
                
                // Create a temporary div to parse SVG
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = cleanedSvg;
                const svgElement = tempDiv.querySelector('svg');
                
                if (!svgElement) {
                    console.warn('No SVG element found, returning original content');
                    return svgContent; // Return original if not valid SVG
                }
                
                // Remove any existing width/height attributes and styles
                svgElement.removeAttribute('width');
                svgElement.removeAttribute('height');
                svgElement.style.width = '';
                svgElement.style.height = '';
                
                // Set fixed size and ensure proper display
                svgElement.setAttribute('width', iconSize.toString());
                svgElement.setAttribute('height', iconSize.toString());
                svgElement.style.display = 'block';
                
                // If no viewBox exists, try to create one from original dimensions or use default
                if (!svgElement.getAttribute('viewBox')) {
                    // Try to find original width/height in the content or use reasonable defaults
                    const originalWidth = cleanedSvg.match(/width\s*=\s*["']?(\d+(?:\.\d+)?)/i);
                    const originalHeight = cleanedSvg.match(/height\s*=\s*["']?(\d+(?:\.\d+)?)/i);
                    
                    const numWidth = originalWidth ? parseFloat(originalWidth[1]) : 24;
                    const numHeight = originalHeight ? parseFloat(originalHeight[1]) : 24;
                    
                    svgElement.setAttribute('viewBox', `0 0 ${numWidth} ${numHeight}`);
                }
                
                // Ensure preserveAspectRatio is set for proper scaling
                if (!svgElement.getAttribute('preserveAspectRatio')) {
                    svgElement.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                }
                
                // Set fill to white if no fill is specified for better visibility on colored backgrounds
                if (!svgElement.getAttribute('fill') && !svgElement.style.fill) {
                    svgElement.setAttribute('fill', 'white');
                }
                
                // Return the processed SVG
                return svgElement.outerHTML;
            } catch (error) {
                console.error('Error processing SVG:', error);
                return svgContent; // Return original on error
            }
        }

        // Import SVG file
        function importSvgFile(index) {
            const fileInput = document.getElementById(`svg-file-${index}`);
            fileInput.click();
        }

        // Handle SVG file import
        function handleSvgFileImport(index, fileInput) {
            const file = fileInput.files[0];
            if (file && file.type === 'image/svg+xml') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const svgContent = e.target.result;
                    
                    // Clean up SVG (remove XML declaration, doctype, etc.)
                    let cleanSvg = svgContent;
                    cleanSvg = cleanSvg.replace(/<\?xml[^>]*\?>/g, '');
                    cleanSvg = cleanSvg.replace(/<!DOCTYPE[^>]*>/g, '');
                    cleanSvg = cleanSvg.trim();
                    
                    // Update textarea and icon
                    const textarea = document.querySelector(`#icon-input-${index} textarea`);
                    if (textarea) {
                        textarea.value = cleanSvg;
                    }
                    
                    updateNodeIcon(index, cleanSvg);
                };
                reader.readAsText(file);
            } else {
                alert('Please select a valid SVG file.');
            }
            
            // Reset file input
            fileInput.value = '';
        }

        // Clear icon
        function clearIcon(index) {
            const textarea = document.querySelector(`#icon-input-${index} textarea`);
            const textInput = document.querySelector(`#icon-input-${index} input[type="text"]`);
            
            if (textarea) {
                textarea.value = '';
            }
            if (textInput) {
                textInput.value = '';
            }
            
            updateNodeIcon(index, '');
        }

        function updateNodeProperty(index, property, value) {
            sankeyData.nodes[index][property] = value;
            
            // Always update the diagram to ensure changes are reflected
            updateDiagram();
            
            // Update the node item title if name changed
            if (property === 'name') {
                updateDataEditor();
            }
        }

        function updateLinkProperty(index, property, value) {
            sankeyData.links[index][property] = value;
            console.log('Updated link property:', property, 'to:', value, 'for link:', sankeyData.links[index].id);
            
            // For source/target changes, need full refresh
            if (property === 'source' || property === 'target') {
                updateDiagram();
                updateDataEditor(); // Refresh to show updated source/target names
            } else {
                // For other properties like color, can update more efficiently
                console.log('Triggering diagram update for link property change');
                updateDiagram();
            }
        }

        function updateLinkGradient(index, gradientProperty, value) {
            const link = sankeyData.links[index];
            console.log('Updating link gradient:', link.id, gradientProperty, 'to:', value);
            
            // Ensure gradient structure exists
            if (!link.style) {
                link.style = {};
            }
            if (!link.style.gradient) {
                link.style.gradient = {};
            }
            
            link.style.gradient[gradientProperty] = value;
            console.log('Link gradient updated:', link.style.gradient);
            console.log('Triggering diagram update for gradient change');
            updateDiagram();
        }

        function deleteNode(index) {
            const nodeId = sankeyData.nodes[index].id;
            
            // Remove node
            sankeyData.nodes.splice(index, 1);
            
            // Remove associated links
            sankeyData.links = sankeyData.links.filter(link => 
                link.source !== nodeId && link.target !== nodeId
            );
            
            updateDataEditor();
            updateDiagram();
        }

        function deleteLink(index) {
            sankeyData.links.splice(index, 1);
            updateDataEditor();
            updateDiagram();
        }

        // File operations
        function saveDataToFile() {
            const dataStr = JSON.stringify(sankeyData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'sankey-data.json';
            link.click();
            
            URL.revokeObjectURL(url);
        }

        function loadDataFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate data structure
                    if (!data.nodes || !data.links || !Array.isArray(data.nodes) || !Array.isArray(data.links)) {
                        throw new Error('Invalid data format');
                    }
                    
                    sankeyData = data;
                    updateDataEditor();
                    updateDiagram();
                    console.log('Data loaded successfully');
                } catch (error) {
                    alert('Error loading file: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }

        // Update node coordinates in data editor when dragged
        function updateNodeCoordinatesInEditor(nodeId, x, y) {
            const nodeIndex = sankeyData.nodes.findIndex(node => node.id === nodeId);
            if (nodeIndex !== -1) {
                // Update the input fields in the editor
                const xInput = document.getElementById(`node-x-${nodeIndex}`);
                const yInput = document.getElementById(`node-y-${nodeIndex}`);
                
                if (xInput) xInput.value = Math.round(x);
                if (yInput) yInput.value = Math.round(y);
            }
        }

        // Show all nodes and links
        function showAllNodesAndLinks() {
            // Make all nodes visible
            sankeyData.nodes.forEach(node => {
                visibleNodes.add(node.id);
            });
            
            // Make all links visible
            sankeyData.links.forEach(link => {
                visibleLinks.add(link.id);
            });
            
            console.log('Showing all nodes and links');
            console.log('Visible nodes:', Array.from(visibleNodes));
            console.log('Visible links:', Array.from(visibleLinks));
            
            // Update visibility
            updateVisibility();
            
            // Update draggable state
            setTimeout(() => {
                updateDraggableNodes();
            }, 100);
        }

        // Load data from JSON file
        async function loadData() {
            try {
                const response = await fetch('data.json');
                sankeyData = await response.json();
                console.log('Loaded data:', sankeyData);
                initializeDiagram();
                updateDataEditor();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('sankey-diagram').innerHTML = '<div class="error">Error loading data</div>';
            }
        }

        // Initialize the diagram
        function initializeDiagram() {
            const container = document.getElementById('sankey-diagram');
            const rect = container.getBoundingClientRect();
            const margin = { top: 20, right: 40, bottom: 20, left: 40 };
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;

            // Clear previous diagram
            d3.select('#sankey-diagram').selectAll('*').remove();

            // Create SVG
            svg = d3.select('#sankey-diagram')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create gradient definitions
            const defs = svg.append('defs');
            createGradients(defs, sankeyData.links);

            // Process data for d3-sankey format
            const { nodes: sankeyNodes, links: sankeyLinks } = processData(sankeyData);

            // Initialize sankey generator
            const sankey = d3.sankey()
                .nodeWidth(60) // Width for circular nodes (diameter)
                .nodePadding(40)
                .extent([[0, 0], [width, height]]);

            // Check if we should use absolute coordinates
            if (config.useAbsoluteCoordinates && hasAbsoluteCoordinates(sankeyData.nodes)) {
                // Apply absolute coordinates directly
                applyAbsoluteCoordinates(sankeyNodes, sankeyData.nodes, width, height);
                
                // Still run sankey to calculate link paths, but preserve node positions
                const sankeyLayout = sankey({ nodes: sankeyNodes, links: sankeyLinks });
                
                // Restore absolute coordinates after sankey calculation
                applyAbsoluteCoordinates(sankeyLayout.nodes, sankeyData.nodes, width, height);
                
                console.log('Using absolute coordinates');
            } else {
                // Use d3-sankey's automatic layout
                sankey({ nodes: sankeyNodes, links: sankeyLinks });
                console.log('Using automatic layout');
            }

            // Draw links
            drawLinks(g, sankeyLinks);

            // Draw nodes
            drawNodes(g, sankeyNodes);

            // Initialize progressive disclosure
            initializeProgressiveDisclosure();
        }

        // Check if data contains absolute coordinates
        function hasAbsoluteCoordinates(nodes) {
            return nodes.some(node => 
                typeof node.x === 'number' && typeof node.y === 'number'
            );
        }

        // Apply absolute coordinates to nodes
        function applyAbsoluteCoordinates(sankeyNodes, originalNodes, width, height) {
            sankeyNodes.forEach(node => {
                const originalNode = originalNodes.find(n => n.id === node.id);
                if (originalNode) {
                    // Use absolute coordinates if provided
                    if (typeof originalNode.x === 'number') {
                        const x = originalNode.x;
                        node.x0 = x;
                        node.x1 = x + 60; // node width
                    }
                    if (typeof originalNode.y === 'number') {
                        const y = originalNode.y;
                        node.y0 = y;
                        node.y1 = y + 60; // node height
                    }
                    
                    // If only x is provided, auto-calculate y based on level and spacing
                    if (typeof originalNode.x === 'number' && typeof originalNode.y !== 'number') {
                        const level = originalNode.level || 0;
                        const nodesAtLevel = originalNodes.filter(n => n.level === level);
                        const nodeIndex = nodesAtLevel.findIndex(n => n.id === node.id);
                        const levelHeight = height / Math.max(1, nodesAtLevel.length);
                        const y = nodeIndex * levelHeight + levelHeight / 2 - 30; // center vertically
                        
                        node.y0 = Math.max(0, Math.min(height - 60, y));
                        node.y1 = node.y0 + 60;
                    }
                    
                    // If only y is provided, keep x from sankey calculation
                    if (typeof originalNode.y === 'number' && typeof originalNode.x !== 'number') {
                        const y = originalNode.y;
                        node.y0 = Math.max(0, Math.min(height - 60, y));
                        node.y1 = node.y0 + 60;
                    }
                }
            });
        }

        // Process data for d3-sankey format
        function processData(data) {
            console.log('Processing data - nodes:', data.nodes.length, 'links:', data.links.length);
            
            // Create a map of node IDs to indices
            const nodeMap = new Map();
            data.nodes.forEach((node, index) => {
                nodeMap.set(node.id, index);
            });

            const nodes = data.nodes.map(d => ({
                ...d,
                name: d.name,
                id: d.id
            }));

            const links = data.links.map(d => {
                const sourceIndex = nodeMap.get(d.source);
                const targetIndex = nodeMap.get(d.target);
                
                if (sourceIndex === undefined) {
                    console.error(`Source node not found: ${d.source}`);
                    return null;
                }
                if (targetIndex === undefined) {
                    console.error(`Target node not found: ${d.target}`);
                    return null;
                }

                const processedLink = {
                    ...d,
                    source: sourceIndex,
                    target: targetIndex,
                    value: d.value
                };
                
                console.log('Processed link:', d.id, d.source, '->', d.target, 'as indices:', sourceIndex, '->', targetIndex);
                return processedLink;
            }).filter(link => link !== null);

            console.log('Processed data:', { nodes: nodes.length, links: links.length });
            return { nodes, links };
        }

        // Create gradient definitions
        function createGradients(defs, linksData) {
            console.log('=== Creating gradients for', linksData.length, 'links ===');
            
            linksData.forEach(link => {
                console.log('Creating gradient for link:', link.id, 'source:', link.source, 'target:', link.target);
                
                const gradientId = `gradient-${link.id}`;
                
                // Remove existing gradient if it exists
                defs.select(`#${gradientId}`).remove();
                
                const gradient = defs.append('linearGradient')
                    .attr('id', gradientId)
                    .attr('gradientUnits', 'objectBoundingBox') // 수정: 객체 비율 기준으로 변경
                    .attr('x1', '0%')  // 시작점: 왼쪽
                    .attr('y1', '0%')  // 시작점: 위쪽
                    .attr('x2', '100%') // 끝점: 오른쪽
                    .attr('y2', '0%');  // 끝점: 위쪽 (수평 그래디언트)

                // Support both old structure (link.style.gradient) and new structure (link.gradient)
                const gradientData = link.style?.gradient || link.gradient || {
                    start: link.color || '#4a90e2',
                    end: d3.color(link.color || '#4a90e2').darker(0.3)
                };

                console.log('Gradient colors for', link.id, ':', gradientData.start, '->', gradientData.end);

                // First stop: start color at 0%
                gradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', gradientData.start);

                // Second stop: maintain start color until 20%
                gradient.append('stop')
                    .attr('offset', '30%')
                    .attr('stop-color', gradientData.start);

                // Third stop: end color at 100%
                gradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', gradientData.end);
            });
            
            console.log('=== Gradients creation complete ===');
        }

        // Draw links
        // Custom variable-width link generator
        function createVariableWidthLink(d) {
            const source = d.source;
            const target = d.target;
            
            // Find source and target node data to check if circles are hidden
            const sourceNodeData = sankeyData.nodes.find(node => node.id === source.id);
            const targetNodeData = sankeyData.nodes.find(node => node.id === target.id);
            
            // Calculate connection points based on whether circles are hidden
            const nodeRadius = 30;
            let sourceX, sourceY, targetX, targetY;
            
            if (sourceNodeData && sourceNodeData.hideCircle) {
                // Connect to center of node when circle is hidden
                sourceX = source.x0 + (source.x1 - source.x0) / 2;
                sourceY = source.y0 + (source.y1 - source.y0) / 2;
            } else {
                // Connect to edge of circle when circle is visible
                sourceX = source.x1;
                sourceY = source.y0 + (source.y1 - source.y0) / 2;
            }
            
            if (targetNodeData && targetNodeData.hideCircle) {
                // Connect to center of node when circle is hidden
                targetX = target.x0 + (target.x1 - target.x0) / 2;
                targetY = target.y0 + (target.y1 - target.y0) / 2;
            } else {
                // Connect to edge of circle when circle is visible
                targetX = target.x0;
                targetY = target.y0 + (target.y1 - target.y0) / 2;
            }
            
            // Calculate widths
            const minWidth = 2;
            const maxWidth = 20;
            const sourceWidth = Math.max(minWidth, Math.min(maxWidth, d.width || d.value * 0.2));
            const targetWidth = sourceWidth; // For now, keep same width, but this can be adjusted
            
            // Control points for smooth curve
            const curvature = 0.5;
            const controlX1 = sourceX + (targetX - sourceX) * curvature;
            const controlX2 = targetX - (targetX - sourceX) * curvature;
            
            // Create path with variable width using multiple segments
            const segments = 20; // Number of segments for smooth width transition
            let path = '';
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                
                // Bezier curve calculation
                const x = Math.pow(1-t, 3) * sourceX + 
                         3 * Math.pow(1-t, 2) * t * controlX1 + 
                         3 * (1-t) * Math.pow(t, 2) * controlX2 + 
                         Math.pow(t, 3) * targetX;
                         
                const y = Math.pow(1-t, 3) * sourceY + 
                         3 * Math.pow(1-t, 2) * t * sourceY + 
                         3 * (1-t) * Math.pow(t, 2) * targetY + 
                         Math.pow(t, 3) * targetY;
                
                // Interpolate width
                const width = sourceWidth + (targetWidth - sourceWidth) * t;
                const halfWidth = width / 2;
                
                if (i === 0) {
                    // Start the path
                    path += `M ${x} ${y - halfWidth}`;
                } else {
                    path += ` L ${x} ${y - halfWidth}`;
                }
            }
            
            // Add the bottom curve
            for (let i = segments; i >= 0; i--) {
                const t = i / segments;
                
                const x = Math.pow(1-t, 3) * sourceX + 
                         3 * Math.pow(1-t, 2) * t * controlX1 + 
                         3 * (1-t) * Math.pow(t, 2) * controlX2 + 
                         Math.pow(t, 3) * targetX;
                         
                const y = Math.pow(1-t, 3) * sourceY + 
                         3 * Math.pow(1-t, 2) * t * sourceY + 
                         3 * (1-t) * Math.pow(t, 2) * targetY + 
                         Math.pow(t, 3) * targetY;
                
                const width = sourceWidth + (targetWidth - sourceWidth) * t;
                const halfWidth = width / 2;
                
                path += ` L ${x} ${y + halfWidth}`;
            }
            
            path += ' Z'; // Close the path
            return path;
        }

                function drawLinks(g, sankeyLinks) {
            console.log('Drawing links:', sankeyLinks.length, 'sankey links');
            console.log('Original data links:', sankeyData.links.length);
            
            const linkGroup = g.append('g')
                .attr('class', 'links');

            links = linkGroup.selectAll('.link')
                .data(sankeyLinks)
                .enter().append('path')
                .attr('class', 'link')
                .attr('d', createVariableWidthLink)
                .attr('fill', d => {
                    // Get source and target IDs with improved logic
                    let sourceId, targetId;
                    
                    // Handle different D3 data structures
                    if (typeof d.source === 'object') {
                        sourceId = d.source.id;
                    } else if (typeof d.source === 'number') {
                        sourceId = sankeyData.nodes[d.source]?.id;
                    } else {
                        sourceId = d.source;
                    }
                    
                    if (typeof d.target === 'object') {
                        targetId = d.target.id;
                    } else if (typeof d.target === 'number') {
                        targetId = sankeyData.nodes[d.target]?.id;
                    } else {
                        targetId = d.target;
                    }
                    
                    // Find matching link in original data
                    const linkData = sankeyData.links.find(link => 
                        link.source === sourceId && link.target === targetId
                    );
                    
                    // Enhanced debugging
                    if (!linkData) {
                        console.warn('❌ No linkData found for:', sourceId, '->', targetId);
                        console.log('Available links:', sankeyData.links.map(l => `${l.source} -> ${l.target}`));
                        console.log('D3 source type:', typeof d.source, 'd.source:', d.source);
                        console.log('D3 target type:', typeof d.target, 'd.target:', d.target);
                        console.log('Resolved sourceId:', sourceId, 'targetId:', targetId);
                    } else {
                        console.log('✅ Link fill for:', sourceId, '->', targetId, 'using gradient:', `gradient-${linkData.id}`);
                    }
                    
                    if (linkData && (linkData.style?.gradient || linkData.gradient)) {
                        return `url(#gradient-${linkData.id})`;
                    } else if (linkData && linkData.color) {
                        return linkData.color;
                    } else {
                        console.warn('⚠️ Using fallback color #999 for link:', sourceId, '->', targetId);
                        return '#999';
                    }
                })
                .attr('stroke', 'none')
                .attr('opacity', 0) // Start completely hidden
                .style('clip-path', 'inset(0 100% 0 0)') // Start with right side clipped

            // Apply additional properties to link containers
            links.classed('link-hidden', d => {
                    // Get source and target IDs with improved logic
                    let sourceId, targetId;
                    
                    if (typeof d.source === 'object') {
                        sourceId = d.source.id;
                    } else if (typeof d.source === 'number') {
                        sourceId = sankeyData.nodes[d.source]?.id;
                    } else {
                        sourceId = d.source;
                    }
                    
                    if (typeof d.target === 'object') {
                        targetId = d.target.id;
                    } else if (typeof d.target === 'number') {
                        targetId = sankeyData.nodes[d.target]?.id;
                    } else {
                        targetId = d.target;
                    }
                    
                    const linkData = sankeyData.links.find(link => 
                        link.source === sourceId && link.target === targetId
                    );
                    return linkData ? !linkData.visible : true;
                })
                .on('mouseover', function(event, d) {
                    if (!isAnimating) {
                        d3.select(this).attr('opacity', 1);
                        // showTooltip(event, d, 'link'); // Temporarily disabled
                    }
                })
                .on('mouseout', function(event, d) {
                    if (!isAnimating) {
                        d3.select(this).attr('opacity', 1.0);  // Fixed opacity to 1.0 (no transparency)
                        // hideTooltip(); // Temporarily disabled
                    }
                });
        }

        // Draw nodes
        function drawNodes(g, sankeyNodes) {
            const nodeGroup = g.append('g')
                .attr('class', 'nodes');

            nodes = nodeGroup.selectAll('.node')
                .data(sankeyNodes)
                .enter().append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x0},${d.y0})`)
                .style('opacity', 0) // Start hidden
                .classed('node-hidden', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    return nodeData ? !nodeData.visible : true;
                })
                .classed('draggable', d => {
                    return config.useAbsoluteCoordinates && visibleNodes.has(d.id);
                })
                .on('click', function(event, d) {
                    event.stopPropagation();
                    if (!isAnimating && !isDragging) {
                        revealConnectedNodes(d.id);
                    }
                })
                .on('mouseover', function(event, d) {
                    if (!isAnimating && !isDragging && visibleNodes.has(d.id)) {
                        // showTooltip(event, d, 'node'); // Temporarily disabled
                    }
                })
                .on('mouseout', function(event, d) {
                    if (!isAnimating && !isDragging) {
                        // hideTooltip(); // Temporarily disabled
                    }
                })
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded)
                );

            // Add circular nodes instead of rectangles (conditionally based on hideCircle property)
            const nodeRadius = 30; // Fixed radius for circular nodes (should match sankey layout)
            
            nodes.append('circle')
                .attr('class', 'node-circle')
                .attr('cx', d => (d.x1 - d.x0) / 2)
                .attr('cy', d => (d.y1 - d.y0) / 2)
                .attr('r', nodeRadius)
                .attr('fill', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    return nodeData ? (nodeData.style?.color || nodeData.color || config.nodeColor) : config.nodeColor;
                })
                .attr('stroke', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    const color = nodeData ? (nodeData.style?.color || nodeData.color || config.nodeColor) : config.nodeColor;
                    return d3.color(color).darker(0.5);
                })
                .attr('stroke-width', 3)
                .style('display', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    return nodeData && nodeData.hideCircle ? 'none' : 'block';
                });

            // Add invisible interaction area for nodes with hidden circles
            nodes.append('circle')
                .attr('class', 'node-interaction-area')
                .attr('cx', d => (d.x1 - d.x0) / 2)
                .attr('cy', d => (d.y1 - d.y0) / 2)
                .attr('r', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    if (nodeData && nodeData.hideCircle) {
                        // Use icon size or minimum interaction area
                        const iconSize = nodeData.iconSize || 24;
                        return Math.max(iconSize / 2, 20); // Minimum 20px radius for easy clicking
                    }
                    return 0; // No interaction area needed when circle is visible
                })
                .style('fill', 'transparent')
                .style('stroke', 'none')
                .style('pointer-events', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    return nodeData && nodeData.hideCircle ? 'all' : 'none';
                });

            // Add icons in the center of circular nodes
            nodes.each(function(d) {
                const nodeElement = d3.select(this);
                const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                const iconContent = nodeData && (nodeData.style?.icon || nodeData.icon) ? (nodeData.style?.icon || nodeData.icon) : '';
                const iconSize = nodeData && nodeData.iconSize ? nodeData.iconSize : 24;
                const halfSize = iconSize / 2;
                
                if (iconContent) {
                    if (iconContent.includes('<svg')) {
                        // SVG icon - use foreignObject with proper SVG formatting
                        const processedSvg = processSvgForIcon(iconContent, iconSize);
                        nodeElement.append('foreignObject')
                            .attr('class', 'node-icon node-icon-svg')
                            .attr('width', iconSize)
                            .attr('height', iconSize)
                            .attr('x', (d.x1 - d.x0) / 2 - halfSize)
                            .attr('y', (d.y1 - d.y0) / 2 - halfSize)
                            .style('overflow', 'visible')
                            .style('pointer-events', 'none')
                            .html(processedSvg);
                    } else {
                        // Text icon (emoji, symbol, or text) - use SVG text
                        const fontSize = Math.max(12, iconSize * 0.75); // Scale font size with icon size
                        nodeElement.append('text')
                            .attr('class', 'node-icon node-icon-text')
                            .attr('x', (d.x1 - d.x0) / 2)
                            .attr('y', (d.y1 - d.y0) / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'central')
                            .style('font-size', `${fontSize}px`)
                            .style('font-weight', 'bold')
                            .style('fill', nodeData && nodeData.hideCircle ? '#333333' : 'white')
                            .style('pointer-events', 'none')
                            .text(iconContent);
                    }
                } else if (!nodeData || !nodeData.hideCircle) {
                    // Default icon if no icon specified and circle is visible
                    nodeElement.append('foreignObject')
                        .attr('class', 'node-icon node-icon-default')
                        .attr('width', iconSize)
                        .attr('height', iconSize)
                        .attr('x', (d.x1 - d.x0) / 2 - halfSize)
                        .attr('y', (d.y1 - d.y0) / 2 - halfSize)
                        .style('overflow', 'visible')
                        .style('pointer-events', 'none')
                        .html(`<svg viewBox="0 0 24 24" width="${iconSize}" height="${iconSize}" style="display: block;"><circle cx="12" cy="12" r="8" fill="white"/></svg>`);
                }
            });

            // Add labels below circular nodes (adjust position based on whether circle is hidden)
            const nodeLabels = nodes.append('text')
                .attr('class', 'node-label')
                .attr('x', d => (d.x1 - d.x0) / 2)
                .attr('y', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    const iconSize = nodeData && nodeData.iconSize ? nodeData.iconSize : 24;
                    const isCircleHidden = nodeData && nodeData.hideCircle;
                    
                    if (isCircleHidden) {
                        // Position label below the icon
                        return (d.y1 - d.y0) / 2 + (iconSize / 2) + 15;
                    } else {
                        // Position label below the circle
                        return (d.y1 - d.y0) / 2 + nodeRadius + 20;
                    }
                })
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('fill', '#333333');

            // Add text content with support for multiple lines
            nodeLabels.each(function(d) {
                const textElement = d3.select(this);
                const lines = d.name.split('\n'); // Split by newline character
                
                if (lines.length === 1) {
                    // Single line - use simple text
                    textElement.text(d.name);
                } else {
                    // Multiple lines - use tspan elements
                    lines.forEach((line, index) => {
                        textElement.append('tspan')
                            .attr('x', (d.x1 - d.x0) / 2) // Keep x position for each line
                            .attr('dy', index === 0 ? 0 : '1.2em') // First line no offset, others 1.2em down
                            .text(line);
                    });
                }
            });
        }

        // Initialize progressive disclosure
        function initializeProgressiveDisclosure() {
            // Set initial visibility based on data
            visibleNodes.clear();
            visibleLinks.clear();
            previouslyVisibleLinks.clear();

            // Check if interactionRules exist, if not initialize with basic visibility
            if (sankeyData.interactionRules && sankeyData.interactionRules.initiallyVisible) {
                sankeyData.interactionRules.initiallyVisible.forEach(nodeId => {
                    visibleNodes.add(nodeId);
                    console.log('Initially visible node:', nodeId);
                });
                
                // Add links that connect initially visible nodes
                sankeyData.links.forEach(link => {
                    if (visibleNodes.has(link.source) && visibleNodes.has(link.target)) {
                        visibleLinks.add(link.id);
                        console.log('Initially visible link:', link.id, 'between', link.source, 'and', link.target);
                    }
                });
                
                console.log('Initial visible nodes:', Array.from(visibleNodes));
                console.log('Initial visible links:', Array.from(visibleLinks));
            } else {
                // If no interaction rules, make all nodes and links visible by default
                console.log('No interaction rules found, showing all nodes and links');
                sankeyData.nodes.forEach(node => {
                    visibleNodes.add(node.id);
                });
                sankeyData.links.forEach(link => {
                    visibleLinks.add(link.id);
                });
            }

            updateVisibility();
        }

        // Update diagram with new configuration
        function updateDiagram() {
            if (!sankeyData || !svg) return;
            
            // Remove existing diagram
            svg.remove();
            
            // Recreate diagram
            initializeDiagram();
        }

        // Update node colors
        function updateNodeColors() {
            if (!nodes) return;
            
            nodes.select('.node-circle')
                .attr('fill', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    return nodeData ? (nodeData.style?.color || nodeData.color || config.nodeColor) : config.nodeColor;
                })
                .attr('stroke', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    const color = nodeData ? (nodeData.style?.color || nodeData.color || config.nodeColor) : config.nodeColor;
                    return d3.color(color).darker(0.5);
                });
        }

        // Update link opacity (DISABLED - always uses 1.0 for no transparency)
        function updateLinkOpacity() {
            if (!links) return;
            
            // Always use opacity 1.0 (completely opaque, no transparency)
            links.attr('opacity', 1.0);
        }

        // Update draggable state of nodes
        function updateDraggableNodes() {
            if (!nodes) return;
            
            nodes.classed('draggable', d => {
                return config.useAbsoluteCoordinates && visibleNodes.has(d.id);
            });
        }

        // Progressive disclosure functionality
        function revealConnectedNodes(nodeId) {
            console.log('=== Revealing nodes connected to:', nodeId, '===');
            
            // Store initial state for comparison
            const initialVisibleNodes = new Set(visibleNodes);
            const initialVisibleLinks = new Set(visibleLinks);
            
            // First check if interaction rules exist
            let connectedNodeIds = [];
            if (sankeyData.interactionRules && sankeyData.interactionRules.progressiveDisclosure) {
                connectedNodeIds = sankeyData.interactionRules.progressiveDisclosure[nodeId] || [];
                console.log('Using interaction rules, found:', connectedNodeIds.length, 'connected nodes:', connectedNodeIds);
            } else {
                // If no interaction rules, discover connected nodes from actual links
                console.log('No interaction rules found, discovering connected nodes from links');
                const connectedSet = new Set();
                
                sankeyData.links.forEach(link => {
                    if (link.source === nodeId) {
                        connectedSet.add(link.target);
                    } else if (link.target === nodeId) {
                        connectedSet.add(link.source);
                    }
                });
                
                connectedNodeIds = Array.from(connectedSet);
                console.log('Discovered', connectedNodeIds.length, 'connected nodes:', connectedNodeIds);
            }
            
            // Add connected nodes to visible set
            connectedNodeIds.forEach(id => {
                if (!visibleNodes.has(id)) {
                    visibleNodes.add(id);
                    console.log('✓ Added NEW node to visible:', id);
                } else {
                    console.log('- Node already visible:', id);
                }
            });
            
            // Add all links between visible nodes (both newly revealed and previously visible)
            let newLinksAdded = 0;
            sankeyData.links.forEach(link => {
                if (visibleNodes.has(link.source) && visibleNodes.has(link.target)) {
                    if (!visibleLinks.has(link.id)) {
                        visibleLinks.add(link.id);
                        console.log('✓ Added NEW link:', link.id, 'between', link.source, '->', link.target);
                        newLinksAdded++;
                    } else {
                        console.log('- Link already visible:', link.id, 'between', link.source, '->', link.target);
                    }
                }
            });

            console.log('Summary:');
            console.log('- Nodes added:', visibleNodes.size - initialVisibleNodes.size);
            console.log('- Links added:', newLinksAdded);
            console.log('- Total visible nodes:', visibleNodes.size);
            console.log('- Total visible links:', visibleLinks.size);
            console.log('=== End reveal ===');

            updateVisibility();
        }

        // Update visibility of nodes and links
        function updateVisibility() {
            if (!nodes || !links) return;

            console.log('=== Updating visibility ===');
            console.log('Current visible nodes:', Array.from(visibleNodes));
            console.log('Current visible links:', Array.from(visibleLinks));
            console.log('Previously visible links:', Array.from(previouslyVisibleLinks));

            // Find newly visible links (links that are visible now but weren't before)
            const newlyVisibleLinks = new Set();
            visibleLinks.forEach(linkId => {
                if (!previouslyVisibleLinks.has(linkId)) {
                    newlyVisibleLinks.add(linkId);
                }
            });
            console.log('Newly visible links:', Array.from(newlyVisibleLinks));

            isAnimating = true;

            // Phase 1: Update node visibility (nodes appear first)
            const nodeTransition = nodes.transition()
                .duration(animationDuration * 0.6) // Nodes animate faster
                .style('opacity', d => visibleNodes.has(d.id) ? 1 : 0.1)
                .style('pointer-events', d => visibleNodes.has(d.id) ? 'all' : 'none');

            // Phase 2: Update link visibility (links appear after nodes with drawing animation)
            let linksProcessed = 0;
            let linksVisible = 0;

            // Wait for nodes to complete before starting link animation
            nodeTransition.end().then(() => {
                const linkTransition = links.transition()
                    .delay(animationDuration * 0.2) // Small delay after nodes complete
                    .duration(animationDuration * 0.8) // Longer duration for drawing effect
                    .style('opacity', d => {
                        linksProcessed++;
                        
                        // Get source and target IDs from D3 processed data
                        let sourceId, targetId;
                        
                        if (typeof d.source === 'object') {
                            sourceId = d.source.id;
                        } else {
                            sourceId = sankeyData.nodes[d.source]?.id;
                        }
                        
                        if (typeof d.target === 'object') {
                            targetId = d.target.id;
                        } else {
                            targetId = sankeyData.nodes[d.target]?.id;
                        }
                        
                        // Find matching link in original data
                        const linkData = sankeyData.links.find(link => 
                            link.source === sourceId && link.target === targetId
                        );
                        
                        if (!linkData) {
                            console.log('⚠️ No link data found for:', sourceId, '->', targetId);
                            return 0;
                        }
                        
                        const isVisible = visibleLinks.has(linkData.id);
                        const opacity = isVisible ? 1.0 : 0;  // Fixed opacity to 1.0 (no transparency)
                        
                        if (isVisible) {
                            linksVisible++;
                            console.log('✓ Link visible:', linkData.id, '(', sourceId, '->', targetId, ') opacity:', opacity);
                        } else {
                            console.log('- Link hidden:', linkData.id, '(', sourceId, '->', targetId, ') opacity:', opacity);
                        }
                        
                        return opacity;
                    })
                    .each(function(d) {
                        // Drawing animation: animate from left to right (only for newly visible links)
                        let sourceId, targetId;
                        
                        if (typeof d.source === 'object') {
                            sourceId = d.source.id;
                        } else {
                            sourceId = sankeyData.nodes[d.source]?.id;
                        }
                        
                        if (typeof d.target === 'object') {
                            targetId = d.target.id;
                        } else {
                            targetId = sankeyData.nodes[d.target]?.id;
                        }
                        
                        const linkData = sankeyData.links.find(link => 
                            link.source === sourceId && link.target === targetId
                        );
                        
                        const linkElement = d3.select(this);
                        
                        if (linkData && visibleLinks.has(linkData.id)) {
                            // Check if this is a newly visible link
                            const isNewlyVisible = newlyVisibleLinks.has(linkData.id);
                            
                            if (isNewlyVisible) {
                                // Remove any existing animation classes first
                                linkElement.classed('drawing', false);
                                
                                // Add drawing animation class after a brief delay
                                setTimeout(() => {
                                    linkElement
                                        .style('opacity', 1.0)  // Fixed opacity to 1.0 (no transparency)
                                        .classed('drawing', true);
                                }, 50);
                            } else {
                                // For previously visible links, just ensure they're visible without animation
                                linkElement
                                    .classed('drawing', false)
                                    .style('opacity', 1.0)  // Fixed opacity to 1.0 (no transparency)
                                    .style('clip-path', 'inset(0 0 0 0)'); // Fully visible
                            }
                        } else {
                            // Hide the link
                            linkElement
                                .classed('drawing', false)
                                .style('opacity', 0)
                                .style('clip-path', 'inset(0 100% 0 0)');
                        }
                    })
                    .style('pointer-events', d => {
                        // Get source and target IDs from D3 processed data
                        let sourceId, targetId;
                        
                        if (typeof d.source === 'object') {
                            sourceId = d.source.id;
                        } else {
                            sourceId = sankeyData.nodes[d.source]?.id;
                        }
                        
                        if (typeof d.target === 'object') {
                            targetId = d.target.id;
                        } else {
                            targetId = sankeyData.nodes[d.target]?.id;
                        }
                        
                        // Find matching link in original data
                        const linkData = sankeyData.links.find(link => 
                            link.source === sourceId && link.target === targetId
                        );
                        
                        if (!linkData) return 'none';
                        return visibleLinks.has(linkData.id) ? 'all' : 'none';
                    });

                // Reset animation flag when link transitions complete
                linkTransition.end()
                    .then(() => {
                        console.log('Visibility update complete:', linksVisible, '/', linksProcessed, 'links visible');
                        console.log('=== End visibility update ===');
                        
                        // Update previously visible links for next time
                        previouslyVisibleLinks.clear();
                        visibleLinks.forEach(linkId => previouslyVisibleLinks.add(linkId));
                        
                        isAnimating = false;
                        // Update draggable state after visibility changes
                        updateDraggableNodes();
                    })
                    .catch(() => {
                        console.log('Visibility update completed with interruption');
                        console.log('=== End visibility update ===');
                        
                        // Update previously visible links for next time
                        previouslyVisibleLinks.clear();
                        visibleLinks.forEach(linkId => previouslyVisibleLinks.add(linkId));
                        
                        isAnimating = false;
                        updateDraggableNodes();
                    });
            }).catch(() => {
                // If node transition fails, still reset animation state
                console.log('Node transition interrupted');
                isAnimating = false;
                updateDraggableNodes();
            });
        }

        // Tooltip functions
        function showTooltip(event, d, type) {
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0)
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.8)')
                .style('color', 'white')
                .style('padding', '10px')
                .style('border-radius', '5px')
                .style('pointer-events', 'none')
                .style('font-size', '12px')
                .style('z-index', '1000');

            let content = '';
            if (type === 'node') {
                const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                content = `<strong>${d.name}</strong><br/>${nodeData ? nodeData.description : ''}`;
            } else if (type === 'link') {
                // Get source and target IDs from D3 processed data
                let sourceId, targetId;
                
                if (typeof d.source === 'object') {
                    sourceId = d.source.id;
                } else {
                    sourceId = sankeyData.nodes[d.source]?.id;
                }
                
                if (typeof d.target === 'object') {
                    targetId = d.target.id;
                } else {
                    targetId = sankeyData.nodes[d.target]?.id;
                }
                
                const linkData = sankeyData.links.find(link => 
                    link.source === sourceId && link.target === targetId
                );
                content = `<strong>${d.source.name} → ${d.target.name}</strong><br/>Value: ${d.value}<br/>${linkData ? linkData.description : ''}`;
            }

            tooltip.html(content)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .transition()
                .duration(200)
                .style('opacity', 1);
        }

        function hideTooltip() {
            d3.selectAll('.tooltip').remove();
        }

        // Drag event handlers
        function dragStarted(event, d) {
            // Only allow dragging in absolute coordinate mode
            if (!config.useAbsoluteCoordinates) {
                return;
            }
            
            // Only allow dragging visible nodes
            if (!visibleNodes.has(d.id)) {
                return;
            }

            isDragging = true;
            draggedNode = d;
            
            // Get the main SVG group for coordinate transformation
            const mainGroup = svg.select('g').node();
            
            // Get mouse position relative to the main group
            const [mouseX, mouseY] = d3.pointer(event, mainGroup);
            
            // Calculate offset between mouse and node center
            const nodeCenterX = d.x0 + 30; // node radius = 30
            const nodeCenterY = d.y0 + 30;
            
            dragOffset.x = mouseX - nodeCenterX;
            dragOffset.y = mouseY - nodeCenterY;
            
            // Add visual feedback
            d3.select(this).classed('dragging', true);
            
            // Disable transitions and animations on all links during drag
            if (links) {
                links.classed('no-transition', true)
                    .classed('drawing', false)
                    .style('animation', 'none')
                    .style('transition', 'none')
                    .style('clip-path', 'inset(0 0 0 0)'); // Show fully during drag
            }
            
            console.log(`Started dragging node: ${d.id} at (${d.x0}, ${d.y0})`);
        }

        function dragged(event, d) {
            if (!isDragging || !config.useAbsoluteCoordinates || !visibleNodes.has(d.id)) {
                return;
            }

            // Get the main SVG group for coordinate transformation
            const mainGroup = svg.select('g').node();
            
            // Get mouse position relative to the main group (this gives us accurate SVG coordinates)
            const [mouseX, mouseY] = d3.pointer(event, mainGroup);

            // Calculate new node position considering the initial offset
            const newCenterX = mouseX - dragOffset.x;
            const newCenterY = mouseY - dragOffset.y;
            
            // Convert center position to top-left corner (d.x0, d.y0)
            const newX = newCenterX - 30; // node radius = 30
            const newY = newCenterY - 30;

            // Get SVG dimensions to constrain movement
            const container = document.getElementById('sankey-diagram');
            const rect = container.getBoundingClientRect();
            const margin = { left: 40, right: 40, top: 20, bottom: 20 };
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            const nodeRadius = 30;

            // Constrain to SVG bounds (considering node radius)
            const constrainedX = Math.max(0, Math.min(width - 60, newX));
            const constrainedY = Math.max(0, Math.min(height - 60, newY));

            // Update node data immediately
            d.x0 = constrainedX;
            d.x1 = constrainedX + 60;
            d.y0 = constrainedY;
            d.y1 = constrainedY + 60;

            // Update visual position immediately without transition
            d3.select(this)
                .interrupt() // Stop any ongoing transitions
                .attr('transform', `translate(${d.x0},${d.y0})`);

            // Update links in real-time with optimized animation frame
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(() => {
                updateLinksPosition();
                animationFrameId = null;
            });
        }

        function dragEnded(event, d) {
            if (!isDragging || !config.useAbsoluteCoordinates) {
                return;
            }

            isDragging = false;
            draggedNode = null;
            
            // Remove visual feedback
            d3.select(this).classed('dragging', false);

            // Re-enable transitions on all links after drag
            if (links) {
                links.classed('no-transition', false)
                    .style('animation', null)
                    .style('transition', null)
                    .style('clip-path', null); // Reset clip-path
            }

            // Update the original data with new coordinates
            const originalNode = sankeyData.nodes.find(node => node.id === d.id);
            if (originalNode) {
                originalNode.x = d.x0;
                originalNode.y = d.y0;
                console.log(`Updated node ${d.id} coordinates: (${d.x0}, ${d.y0})`);
                
                // Update the data editor with new coordinates
                updateNodeCoordinatesInEditor(d.id, d.x0, d.y0);
            }

            // Cancel any pending animation frame
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Final link update (now with transitions re-enabled for smooth settling)
            updateLinksPosition();
        }

        // Update link positions during drag
        function updateLinksPosition() {
            if (!links) return;

            if (isDragging) {
                // During drag: immediate update with no transitions or animations
                links
                    .interrupt() // Stop any ongoing transitions
                    .classed('no-transition', true)
                    .classed('drawing', false)
                    .style('animation', 'none')
                    .style('transition', 'none')
                    .style('clip-path', 'inset(0 0 0 0)') // Show fully during drag
                    .attr('d', createVariableWidthLink);
            } else {
                // After drag: allow smooth transitions for settling
                links
                    .classed('no-transition', false)
                    .style('animation', null)
                    .style('transition', null)
                    .style('clip-path', null) // Reset clip-path
                    .attr('d', createVariableWidthLink);
            }
        }

        // Window resize handler
        window.addEventListener('resize', function() {
            if (svg) {
                updateDiagram();
            }
        });
    </script>
</body>
</html> 