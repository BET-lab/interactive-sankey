<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sankey Diagram</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #333333;
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 10px;
        }

        .header p {
            color: rgba(0, 0, 0, 0.6);
            font-size: 1rem;
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .controls h3 {
            color: #333333;
            margin-bottom: 15px;
            font-weight: 400;
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-item label {
            color: rgba(0, 0, 0, 0.8);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .control-item input[type="range"],
        .control-item input[type="color"],
        .control-item select {
            padding: 8px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.05);
            color: #333333;
        }

        .control-item input[type="range"] {
            width: 120px;
        }

        .control-item select {
            min-width: 100px;
        }

        .control-item select option {
            background: #ffffff;
            color: #333333;
        }

        .control-item input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .control-item label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .visualization-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.02);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
        }

        #sankey-diagram {
            width: 100%;
            height: 100%;
            min-height: 500px;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node.draggable {
            cursor: grab;
        }

        .node:hover .node-circle {
            stroke-width: 4;
            filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
        }

        .node.dragging {
            cursor: grabbing !important;
            transition: none !important; /* Disable transitions during drag */
        }

        .node.dragging .node-circle {
            stroke-width: 5;
            filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.5));
            transition: none !important; /* Disable transitions during drag */
        }

        /* Remove hover transform to prevent jittering */

        .node-circle {
            fill: #4a90e2;
            stroke: #2c5aa0;
            stroke-width: 3;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .node-icon {
            pointer-events: none;
        }

        .node-label {
            font-size: 12px;
            font-weight: 500;
            fill: #333333;
            text-anchor: middle;
            pointer-events: none;
        }

        .link {
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        /* Link hover handled via JavaScript to prevent conflicts */

        .link-hidden {
            opacity: 0;
            pointer-events: none;
        }

        .node-hidden {
            opacity: 0.1;
            pointer-events: none;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .tooltip strong {
            color: #4a90e2;
            display: block;
            margin-bottom: 4px;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #333333;
            font-size: 1.2rem;
        }

        .error {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #ff6b6b;
            font-size: 1.2rem;
            text-align: center;
        }



        .link {
            cursor: pointer;
        }

        .links path {
            mix-blend-mode: multiply;
        }

        @media (max-width: 768px) {
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-item {
                width: 100%;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Interactive Sankey Diagram</h1>
        <p>Click on nodes to explore the flow relationships</p>
    </div>

    <div class="container">
        <div class="controls">
            <h3>Customization Controls</h3>
            <div class="control-group">
                <div class="control-item">
                    <label for="nodeWidth">Node Width</label>
                    <input type="range" id="nodeWidth" min="10" max="50" value="20">
                </div>
                <div class="control-item">
                    <label for="nodePadding">Node Padding</label>
                    <input type="range" id="nodePadding" min="5" max="30" value="10">
                </div>
                <div class="control-item">
                    <label for="nodeColor">Node Color</label>
                    <input type="color" id="nodeColor" value="#4a90e2">
                </div>
                <div class="control-item">
                    <label for="linkOpacity">Link Opacity</label>
                    <input type="range" id="linkOpacity" min="0.1" max="1" step="0.1" value="0.7">
                </div>
                <div class="control-item">
                    <label for="animationSpeed">Animation Speed</label>
                    <select id="animationSpeed">
                        <option value="0.2">Fast</option>
                        <option value="0.5" selected>Normal</option>
                        <option value="1">Slow</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>
                        <input type="checkbox" id="coordinateMode" checked>
                        Use Absolute Coordinates
                    </label>
                    <small style="color: rgba(0,0,0,0.6); font-size: 0.8rem; margin-top: 2px;">
                        Enable node dragging
                    </small>
                </div>
            </div>
        </div>

        <div class="visualization-container">
            <div id="sankey-diagram">
                <div class="loading">Loading Sankey diagram...</div>
            </div>
        </div>
    </div>

    <!-- D3.js and d3-sankey libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

    <script>
        // Configuration
        const config = {
            linkOpacity: 0.7,
            nodeColor: '#4a90e2',
            animationDuration: 500,
            useAbsoluteCoordinates: true  // New: Enable absolute coordinate mode
        };

        // Animation state
        let isAnimating = false;
        const animationDuration = config.animationDuration;

        // Drag state
        let isDragging = false;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };

        // Progressive disclosure state
        const visibleNodes = new Set();
        const visibleLinks = new Set();

        // Global references for updates
        let sankeyData = null;
        let svg = null;
        let nodes = null;
        let links = null;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing Sankey diagram...');
            initializeControls();
            loadData();
        });

        // Initialize control event listeners
        function initializeControls() {
            document.getElementById('nodeWidth').addEventListener('input', function(e) {
                config.nodeWidth = parseInt(e.target.value);
                updateDiagram();
            });

            document.getElementById('nodePadding').addEventListener('input', function(e) {
                config.nodePadding = parseInt(e.target.value);
                updateDiagram();
            });

            document.getElementById('nodeColor').addEventListener('input', function(e) {
                config.nodeColor = e.target.value;
                updateNodeColors();
            });

            document.getElementById('linkOpacity').addEventListener('input', function(e) {
                config.linkOpacity = parseFloat(e.target.value);
                updateLinkOpacity();
            });

            document.getElementById('animationSpeed').addEventListener('change', function(e) {
                config.animationSpeed = parseFloat(e.target.value);
                animationDuration = config.animationSpeed * 1000;
            });

            document.getElementById('coordinateMode').addEventListener('change', function(e) {
                config.useAbsoluteCoordinates = e.target.checked;
                updateDiagram();
                // Update draggable state immediately for better UX
                setTimeout(() => {
                    updateDraggableNodes();
                }, 100);
            });
        }

        // Load data from JSON file
        async function loadData() {
            try {
                const response = await fetch('data.json');
                sankeyData = await response.json();
                console.log('Loaded data:', sankeyData);
                initializeDiagram();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('sankey-diagram').innerHTML = '<div class="error">Error loading data</div>';
            }
        }

        // Initialize the diagram
        function initializeDiagram() {
            const container = document.getElementById('sankey-diagram');
            const rect = container.getBoundingClientRect();
            const margin = { top: 20, right: 40, bottom: 20, left: 40 };
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;

            // Clear previous diagram
            d3.select('#sankey-diagram').selectAll('*').remove();

            // Create SVG
            svg = d3.select('#sankey-diagram')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create gradient definitions
            const defs = svg.append('defs');
            createGradients(defs, sankeyData.links);

            // Process data for d3-sankey format
            const { nodes: sankeyNodes, links: sankeyLinks } = processData(sankeyData);

            // Initialize sankey generator
            const sankey = d3.sankey()
                .nodeWidth(60) // Width for circular nodes (diameter)
                .nodePadding(40)
                .extent([[0, 0], [width, height]]);

            // Check if we should use absolute coordinates
            if (config.useAbsoluteCoordinates && hasAbsoluteCoordinates(sankeyData.nodes)) {
                // Apply absolute coordinates directly
                applyAbsoluteCoordinates(sankeyNodes, sankeyData.nodes, width, height);
                
                // Still run sankey to calculate link paths, but preserve node positions
                const sankeyLayout = sankey({ nodes: sankeyNodes, links: sankeyLinks });
                
                // Restore absolute coordinates after sankey calculation
                applyAbsoluteCoordinates(sankeyLayout.nodes, sankeyData.nodes, width, height);
                
                console.log('Using absolute coordinates');
            } else {
                // Use d3-sankey's automatic layout
                sankey({ nodes: sankeyNodes, links: sankeyLinks });
                console.log('Using automatic layout');
            }

            // Draw links
            drawLinks(g, sankeyLinks);

            // Draw nodes
            drawNodes(g, sankeyNodes);

            // Initialize progressive disclosure
            initializeProgressiveDisclosure();
        }

        // Check if data contains absolute coordinates
        function hasAbsoluteCoordinates(nodes) {
            return nodes.some(node => 
                typeof node.x === 'number' && typeof node.y === 'number'
            );
        }

        // Apply absolute coordinates to nodes
        function applyAbsoluteCoordinates(sankeyNodes, originalNodes, width, height) {
            sankeyNodes.forEach(node => {
                const originalNode = originalNodes.find(n => n.id === node.id);
                if (originalNode) {
                    // Use absolute coordinates if provided
                    if (typeof originalNode.x === 'number') {
                        const x = originalNode.x;
                        node.x0 = x;
                        node.x1 = x + 60; // node width
                    }
                    if (typeof originalNode.y === 'number') {
                        const y = originalNode.y;
                        node.y0 = y;
                        node.y1 = y + 60; // node height
                    }
                    
                    // If only x is provided, auto-calculate y based on level and spacing
                    if (typeof originalNode.x === 'number' && typeof originalNode.y !== 'number') {
                        const level = originalNode.level || 0;
                        const nodesAtLevel = originalNodes.filter(n => n.level === level);
                        const nodeIndex = nodesAtLevel.findIndex(n => n.id === node.id);
                        const levelHeight = height / Math.max(1, nodesAtLevel.length);
                        const y = nodeIndex * levelHeight + levelHeight / 2 - 30; // center vertically
                        
                        node.y0 = Math.max(0, Math.min(height - 60, y));
                        node.y1 = node.y0 + 60;
                    }
                    
                    // If only y is provided, keep x from sankey calculation
                    if (typeof originalNode.y === 'number' && typeof originalNode.x !== 'number') {
                        const y = originalNode.y;
                        node.y0 = Math.max(0, Math.min(height - 60, y));
                        node.y1 = node.y0 + 60;
                    }
                }
            });
        }

        // Process data for d3-sankey format
        function processData(data) {
            // Create a map of node IDs to indices
            const nodeMap = new Map();
            data.nodes.forEach((node, index) => {
                nodeMap.set(node.id, index);
            });

            const nodes = data.nodes.map(d => ({
                ...d,
                name: d.name,
                id: d.id
            }));

            const links = data.links.map(d => {
                const sourceIndex = nodeMap.get(d.source);
                const targetIndex = nodeMap.get(d.target);
                
                if (sourceIndex === undefined) {
                    console.error(`Source node not found: ${d.source}`);
                    return null;
                }
                if (targetIndex === undefined) {
                    console.error(`Target node not found: ${d.target}`);
                    return null;
                }

                return {
                    ...d,
                    source: sourceIndex,
                    target: targetIndex,
                    value: d.value
                };
            }).filter(link => link !== null);

            console.log('Processed data:', { nodes, links });
            return { nodes, links };
        }

        // Create gradient definitions
        function createGradients(defs, linksData) {
            linksData.forEach(link => {
                const gradientId = `gradient-${link.id}`;
                const gradient = defs.append('linearGradient')
                    .attr('id', gradientId)
                    .attr('gradientUnits', 'userSpaceOnUse');

                gradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', link.style.gradient.start);

                gradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', link.style.gradient.end);
            });
        }

        // Draw links
        // Custom variable-width link generator
        function createVariableWidthLink(d) {
            const source = d.source;
            const target = d.target;
            
            // Get source and target positions (center of circular nodes)
            const sourceX = source.x1;
            const sourceY = source.y0 + (source.y1 - source.y0) / 2;
            const targetX = target.x0;
            const targetY = target.y0 + (target.y1 - target.y0) / 2;
            
            // Calculate widths
            const minWidth = 2;
            const maxWidth = 20;
            const sourceWidth = Math.max(minWidth, Math.min(maxWidth, d.width || d.value * 0.2));
            const targetWidth = sourceWidth; // For now, keep same width, but this can be adjusted
            
            // Control points for smooth curve
            const curvature = 0.5;
            const controlX1 = sourceX + (targetX - sourceX) * curvature;
            const controlX2 = targetX - (targetX - sourceX) * curvature;
            
            // Create path with variable width using multiple segments
            const segments = 20; // Number of segments for smooth width transition
            let path = '';
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                
                // Bezier curve calculation
                const x = Math.pow(1-t, 3) * sourceX + 
                         3 * Math.pow(1-t, 2) * t * controlX1 + 
                         3 * (1-t) * Math.pow(t, 2) * controlX2 + 
                         Math.pow(t, 3) * targetX;
                         
                const y = Math.pow(1-t, 3) * sourceY + 
                         3 * Math.pow(1-t, 2) * t * sourceY + 
                         3 * (1-t) * Math.pow(t, 2) * targetY + 
                         Math.pow(t, 3) * targetY;
                
                // Interpolate width
                const width = sourceWidth + (targetWidth - sourceWidth) * t;
                const halfWidth = width / 2;
                
                if (i === 0) {
                    // Start the path
                    path += `M ${x} ${y - halfWidth}`;
                } else {
                    path += ` L ${x} ${y - halfWidth}`;
                }
            }
            
            // Add the bottom curve
            for (let i = segments; i >= 0; i--) {
                const t = i / segments;
                
                const x = Math.pow(1-t, 3) * sourceX + 
                         3 * Math.pow(1-t, 2) * t * controlX1 + 
                         3 * (1-t) * Math.pow(t, 2) * controlX2 + 
                         Math.pow(t, 3) * targetX;
                         
                const y = Math.pow(1-t, 3) * sourceY + 
                         3 * Math.pow(1-t, 2) * t * sourceY + 
                         3 * (1-t) * Math.pow(t, 2) * targetY + 
                         Math.pow(t, 3) * targetY;
                
                const width = sourceWidth + (targetWidth - sourceWidth) * t;
                const halfWidth = width / 2;
                
                path += ` L ${x} ${y + halfWidth}`;
            }
            
            path += ' Z'; // Close the path
            return path;
        }

        function drawLinks(g, sankeyLinks) {
            const linkGroup = g.append('g')
                .attr('class', 'links');

            links = linkGroup.selectAll('.link')
                .data(sankeyLinks)
                .enter().append('path')
                .attr('class', 'link')
                .attr('d', createVariableWidthLink)
                .attr('fill', d => {
                    const sourceId = sankeyData.nodes[d.source.index || d.source]?.id;
                    const targetId = sankeyData.nodes[d.target.index || d.target]?.id;
                    const linkData = sankeyData.links.find(link => 
                        link.source === sourceId && link.target === targetId
                    );
                    return linkData ? `url(#gradient-${linkData.id})` : '#999';
                })
                .attr('stroke', 'none')
                .attr('opacity', config.linkOpacity)
                .classed('link-hidden', d => {
                    const sourceId = sankeyData.nodes[d.source.index || d.source]?.id;
                    const targetId = sankeyData.nodes[d.target.index || d.target]?.id;
                    const linkData = sankeyData.links.find(link => 
                        link.source === sourceId && link.target === targetId
                    );
                    return linkData ? !linkData.visible : true;
                })
                .on('mouseover', function(event, d) {
                    if (!isAnimating) {
                        d3.select(this).attr('opacity', 1);
                        // showTooltip(event, d, 'link'); // Temporarily disabled
                    }
                })
                .on('mouseout', function(event, d) {
                    if (!isAnimating) {
                        d3.select(this).attr('opacity', config.linkOpacity);
                        // hideTooltip(); // Temporarily disabled
                    }
                });
        }

        // Draw nodes
        function drawNodes(g, sankeyNodes) {
            const nodeGroup = g.append('g')
                .attr('class', 'nodes');

            nodes = nodeGroup.selectAll('.node')
                .data(sankeyNodes)
                .enter().append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x0},${d.y0})`)
                .classed('node-hidden', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    return nodeData ? !nodeData.visible : true;
                })
                .classed('draggable', d => {
                    return config.useAbsoluteCoordinates && visibleNodes.has(d.id);
                })
                .on('click', function(event, d) {
                    event.stopPropagation();
                    if (!isAnimating && !isDragging) {
                        revealConnectedNodes(d.id);
                    }
                })
                .on('mouseover', function(event, d) {
                    if (!isAnimating && !isDragging && visibleNodes.has(d.id)) {
                        // showTooltip(event, d, 'node'); // Temporarily disabled
                    }
                })
                .on('mouseout', function(event, d) {
                    if (!isAnimating && !isDragging) {
                        // hideTooltip(); // Temporarily disabled
                    }
                })
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded)
                );

            // Add circular nodes instead of rectangles
            const nodeRadius = 30; // Fixed radius for circular nodes (should match sankey layout)
            
            nodes.append('circle')
                .attr('class', 'node-circle')
                .attr('cx', d => (d.x1 - d.x0) / 2)
                .attr('cy', d => (d.y1 - d.y0) / 2)
                .attr('r', nodeRadius)
                .attr('fill', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    return nodeData ? nodeData.style.color : config.nodeColor;
                })
                .attr('stroke', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    const color = nodeData ? nodeData.style.color : config.nodeColor;
                    return d3.color(color).darker(0.5);
                })
                .attr('stroke-width', 3);

            // Add icons in the center of circular nodes
            nodes.append('foreignObject')
                .attr('class', 'node-icon')
                .attr('width', 24)
                .attr('height', 24)
                .attr('x', d => (d.x1 - d.x0) / 2 - 12)
                .attr('y', d => (d.y1 - d.y0) / 2 - 12)
                .html(d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    return nodeData && nodeData.style.icon ? nodeData.style.icon : 
                        '<svg viewBox="0 0 24 24" width="20" height="20"><circle cx="12" cy="12" r="8" fill="white"/></svg>';
                });

            // Add labels below circular nodes
            nodes.append('text')
                .attr('class', 'node-label')
                .attr('x', d => (d.x1 - d.x0) / 2)
                .attr('y', d => (d.y1 - d.y0) / 2 + nodeRadius + 20)
                .attr('text-anchor', 'middle')
                .text(d => d.name)
                .style('font-size', '12px')
                .style('fill', '#333333');
        }

        // Initialize progressive disclosure
        function initializeProgressiveDisclosure() {
            // Set initial visibility based on data
            visibleNodes.clear();
            visibleLinks.clear();

            sankeyData.interactionRules.initiallyVisible.forEach(nodeId => {
                visibleNodes.add(nodeId);
                
                // Also add any links connected to initially visible nodes
                sankeyData.links.forEach(link => {
                    if (link.source === nodeId || link.target === nodeId) {
                        // Check if the other end of the link should also be visible
                        const otherNodeId = link.source === nodeId ? link.target : link.source;
                        if (sankeyData.interactionRules.initiallyVisible.includes(otherNodeId)) {
                            visibleLinks.add(link.id);
                        }
                    }
                });
            });

            updateVisibility();
        }

        // Update diagram with new configuration
        function updateDiagram() {
            if (!sankeyData || !svg) return;
            
            // Remove existing diagram
            svg.remove();
            
            // Recreate diagram
            initializeDiagram();
        }

        // Update node colors
        function updateNodeColors() {
            if (!nodes) return;
            
            nodes.select('.node-circle')
                .attr('fill', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    return nodeData ? nodeData.style.color : config.nodeColor;
                })
                .attr('stroke', d => {
                    const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                    const color = nodeData ? nodeData.style.color : config.nodeColor;
                    return d3.color(color).darker(0.5);
                });
        }

        // Update link opacity
        function updateLinkOpacity() {
            if (!links) return;
            
            links.attr('opacity', config.linkOpacity);
        }

        // Update draggable state of nodes
        function updateDraggableNodes() {
            if (!nodes) return;
            
            nodes.classed('draggable', d => {
                return config.useAbsoluteCoordinates && visibleNodes.has(d.id);
            });
        }

        // Progressive disclosure functionality
        function revealConnectedNodes(nodeId) {
            console.log('Revealing nodes connected to:', nodeId);
            
            const connectedNodeIds = sankeyData.interactionRules.progressiveDisclosure[nodeId] || [];
            
            // Add connected nodes to visible set
            connectedNodeIds.forEach(id => {
                visibleNodes.add(id);
                
                // Find and add direct links between clicked node and newly added node
                sankeyData.links.forEach(link => {
                    if ((link.source === nodeId && link.target === id) ||
                        (link.target === nodeId && link.source === id)) {
                        visibleLinks.add(link.id);
                        console.log('Added direct link:', link.id, 'between', nodeId, 'and', id);
                    }
                });
            });
            
            // Also add any other links between all visible nodes (for completeness)
            sankeyData.links.forEach(link => {
                if (visibleNodes.has(link.source) && visibleNodes.has(link.target)) {
                    visibleLinks.add(link.id);
                }
            });

            console.log('Visible nodes:', Array.from(visibleNodes));
            console.log('Visible links:', Array.from(visibleLinks));

            updateVisibility();
        }

        // Update visibility of nodes and links
        function updateVisibility() {
            if (!nodes || !links) return;

            isAnimating = true;

            // Update node visibility
            const nodeTransition = nodes.transition()
                .duration(animationDuration)
                .style('opacity', d => visibleNodes.has(d.id) ? 1 : 0.1)
                .style('pointer-events', d => visibleNodes.has(d.id) ? 'all' : 'none');

            // Update link visibility
            const linkTransition = links.transition()
                .duration(animationDuration)
                .style('opacity', d => {
                    // Get source and target IDs from D3 processed data
                    let sourceId, targetId;
                    
                    if (typeof d.source === 'object') {
                        sourceId = d.source.id;
                    } else {
                        sourceId = sankeyData.nodes[d.source]?.id;
                    }
                    
                    if (typeof d.target === 'object') {
                        targetId = d.target.id;
                    } else {
                        targetId = sankeyData.nodes[d.target]?.id;
                    }
                    
                    // Find matching link in original data
                    const linkData = sankeyData.links.find(link => 
                        link.source === sourceId && link.target === targetId
                    );
                    
                    if (!linkData) {
                        console.log('No link data found for:', sourceId, '->', targetId);
                        return 0;
                    }
                    
                    const isVisible = visibleLinks.has(linkData.id);
                    console.log('Link', linkData.id, 'visibility:', isVisible, 'opacity:', isVisible ? config.linkOpacity : 0);
                    
                    return isVisible ? config.linkOpacity : 0;
                })
                .style('pointer-events', d => {
                    // Get source and target IDs from D3 processed data
                    let sourceId, targetId;
                    
                    if (typeof d.source === 'object') {
                        sourceId = d.source.id;
                    } else {
                        sourceId = sankeyData.nodes[d.source]?.id;
                    }
                    
                    if (typeof d.target === 'object') {
                        targetId = d.target.id;
                    } else {
                        targetId = sankeyData.nodes[d.target]?.id;
                    }
                    
                    // Find matching link in original data
                    const linkData = sankeyData.links.find(link => 
                        link.source === sourceId && link.target === targetId
                    );
                    
                    if (!linkData) return 'none';
                    return visibleLinks.has(linkData.id) ? 'all' : 'none';
                });

            // Reset animation flag when both transitions complete
            Promise.all([nodeTransition.end(), linkTransition.end()])
                .then(() => {
                    isAnimating = false;
                    // Update draggable state after visibility changes
                    updateDraggableNodes();
                })
                .catch(() => {
                    isAnimating = false;
                    updateDraggableNodes();
                });
        }

        // Tooltip functions
        function showTooltip(event, d, type) {
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0)
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.8)')
                .style('color', 'white')
                .style('padding', '10px')
                .style('border-radius', '5px')
                .style('pointer-events', 'none')
                .style('font-size', '12px')
                .style('z-index', '1000');

            let content = '';
            if (type === 'node') {
                const nodeData = sankeyData.nodes.find(node => node.id === d.id);
                content = `<strong>${d.name}</strong><br/>${nodeData ? nodeData.description : ''}`;
            } else if (type === 'link') {
                // Get source and target IDs from D3 processed data
                let sourceId, targetId;
                
                if (typeof d.source === 'object') {
                    sourceId = d.source.id;
                } else {
                    sourceId = sankeyData.nodes[d.source]?.id;
                }
                
                if (typeof d.target === 'object') {
                    targetId = d.target.id;
                } else {
                    targetId = sankeyData.nodes[d.target]?.id;
                }
                
                const linkData = sankeyData.links.find(link => 
                    link.source === sourceId && link.target === targetId
                );
                content = `<strong>${d.source.name} → ${d.target.name}</strong><br/>Value: ${d.value}<br/>${linkData ? linkData.description : ''}`;
            }

            tooltip.html(content)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .transition()
                .duration(200)
                .style('opacity', 1);
        }

        function hideTooltip() {
            d3.selectAll('.tooltip').remove();
        }

        // Drag event handlers
        function dragStarted(event, d) {
            // Only allow dragging in absolute coordinate mode
            if (!config.useAbsoluteCoordinates) {
                return;
            }
            
            // Only allow dragging visible nodes
            if (!visibleNodes.has(d.id)) {
                return;
            }

            isDragging = true;
            draggedNode = d;
            
            // Get the main SVG group for coordinate transformation
            const mainGroup = svg.select('g').node();
            
            // Get mouse position relative to the main group
            const [mouseX, mouseY] = d3.pointer(event, mainGroup);
            
            // Calculate offset between mouse and node center
            const nodeCenterX = d.x0 + 30; // node radius = 30
            const nodeCenterY = d.y0 + 30;
            
            dragOffset.x = mouseX - nodeCenterX;
            dragOffset.y = mouseY - nodeCenterY;
            
            // Add visual feedback
            d3.select(this).classed('dragging', true);
            console.log(`Started dragging node: ${d.id} at (${d.x0}, ${d.y0})`);
        }

        function dragged(event, d) {
            if (!isDragging || !config.useAbsoluteCoordinates || !visibleNodes.has(d.id)) {
                return;
            }

            // Get the main SVG group for coordinate transformation
            const mainGroup = svg.select('g').node();
            
            // Get mouse position relative to the main group (this gives us accurate SVG coordinates)
            const [mouseX, mouseY] = d3.pointer(event, mainGroup);

            // Calculate new node position considering the initial offset
            const newCenterX = mouseX - dragOffset.x;
            const newCenterY = mouseY - dragOffset.y;
            
            // Convert center position to top-left corner (d.x0, d.y0)
            const newX = newCenterX - 30; // node radius = 30
            const newY = newCenterY - 30;

            // Get SVG dimensions to constrain movement
            const container = document.getElementById('sankey-diagram');
            const rect = container.getBoundingClientRect();
            const margin = { left: 40, right: 40, top: 20, bottom: 20 };
            const width = rect.width - margin.left - margin.right;
            const height = rect.height - margin.top - margin.bottom;
            const nodeRadius = 30;

            // Constrain to SVG bounds (considering node radius)
            const constrainedX = Math.max(0, Math.min(width - 60, newX));
            const constrainedY = Math.max(0, Math.min(height - 60, newY));

            // Update node data immediately
            d.x0 = constrainedX;
            d.x1 = constrainedX + 60;
            d.y0 = constrainedY;
            d.y1 = constrainedY + 60;

            // Update visual position immediately without transition
            d3.select(this)
                .interrupt() // Stop any ongoing transitions
                .attr('transform', `translate(${d.x0},${d.y0})`);

            // Update links in real-time
            updateLinksPosition();
        }

        function dragEnded(event, d) {
            if (!isDragging || !config.useAbsoluteCoordinates) {
                return;
            }

            isDragging = false;
            draggedNode = null;
            
            // Remove visual feedback
            d3.select(this).classed('dragging', false);

            // Update the original data with new coordinates
            const originalNode = sankeyData.nodes.find(node => node.id === d.id);
            if (originalNode) {
                originalNode.x = d.x0;
                originalNode.y = d.y0;
                console.log(`Updated node ${d.id} coordinates: (${d.x0}, ${d.y0})`);
            }

            // Final link update
            updateLinksPosition();
        }

        // Update link positions during drag
        function updateLinksPosition() {
            if (!links) return;

            // Update links immediately without transition for smooth dragging
            links
                .interrupt() // Stop any ongoing transitions
                .attr('d', createVariableWidthLink);
        }

        // Window resize handler
        window.addEventListener('resize', function() {
            if (svg) {
                updateDiagram();
            }
        });
    </script>
</body>
</html> 